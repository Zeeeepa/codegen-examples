"""
OWASP ZAP security scanning configuration and automation.
"""
import json
import time
import requests
from zapv2 import ZAPv2
from typing import Dict, List, Optional
import logging


class ZAPSecurityScanner:
    """OWASP ZAP security scanner for automated vulnerability testing."""
    
    def __init__(self, zap_proxy_url: str = "http://127.0.0.1:8080", api_key: Optional[str] = None):
        """Initialize ZAP scanner."""
        self.zap_proxy_url = zap_proxy_url
        self.zap = ZAPv2(proxies={'http': zap_proxy_url, 'https': zap_proxy_url}, apikey=api_key)
        self.logger = logging.getLogger(__name__)
        
    def start_zap_daemon(self) -> bool:
        """Start ZAP daemon if not already running."""
        try:
            # Check if ZAP is already running
            response = requests.get(f"{self.zap_proxy_url}/JSON/core/view/version/")
            if response.status_code == 200:
                self.logger.info("ZAP daemon is already running")
                return True
        except requests.exceptions.ConnectionError:
            self.logger.info("ZAP daemon not running, attempting to start...")
            # In a real implementation, you would start ZAP daemon here
            # For testing purposes, we'll assume it's available
            return False
    
    def configure_scanner(self, config: Dict) -> None:
        """Configure ZAP scanner settings."""
        # Set scanner policies
        if 'scan_policy' in config:
            self.zap.ascan.set_option_scan_policy(config['scan_policy'])
        
        # Configure authentication if provided
        if 'auth' in config:
            self._configure_authentication(config['auth'])
        
        # Set custom headers
        if 'headers' in config:
            for header_name, header_value in config['headers'].items():
                self.zap.replacer.add_rule(
                    description=f"Add {header_name} header",
                    enabled=True,
                    matchtype="REQ_HEADER",
                    matchregex=False,
                    matchstring=header_name,
                    replacement=header_value
                )
    
    def _configure_authentication(self, auth_config: Dict) -> None:
        """Configure authentication for scanning."""
        if auth_config.get('type') == 'form':
            # Configure form-based authentication
            context_id = self.zap.context.new_context(auth_config.get('context_name', 'Default'))
            
            # Set authentication method
            self.zap.authentication.set_authentication_method(
                contextid=context_id,
                authmethodname='formBasedAuthentication',
                authmethodconfigparams=f"loginUrl={auth_config['login_url']}&loginRequestData={auth_config['login_data']}"
            )
            
            # Add user
            user_id = self.zap.users.new_user(context_id, auth_config.get('username', 'testuser'))
            self.zap.users.set_authentication_credentials(
                contextid=context_id,
                userid=user_id,
                authcredentialsconfigparams=f"username={auth_config['username']}&password={auth_config['password']}"
            )
            
            self.zap.users.set_user_enabled(context_id, user_id, True)
    
    def spider_scan(self, target_url: str, max_depth: int = 5) -> str:
        """Perform spider scan to discover URLs."""
        self.logger.info(f"Starting spider scan on {target_url}")
        
        # Start spider scan
        scan_id = self.zap.spider.scan(target_url, maxchildren=max_depth)
        
        # Wait for spider to complete
        while int(self.zap.spider.status(scan_id)) < 100:
            self.logger.info(f"Spider progress: {self.zap.spider.status(scan_id)}%")
            time.sleep(2)
        
        self.logger.info("Spider scan completed")
        return scan_id
    
    def active_scan(self, target_url: str, scan_policy: Optional[str] = None) -> str:
        """Perform active vulnerability scan."""
        self.logger.info(f"Starting active scan on {target_url}")
        
        # Start active scan
        if scan_policy:
            scan_id = self.zap.ascan.scan(target_url, scanpolicyname=scan_policy)
        else:
            scan_id = self.zap.ascan.scan(target_url)
        
        # Monitor scan progress
        while int(self.zap.ascan.status(scan_id)) < 100:
            progress = self.zap.ascan.status(scan_id)
            self.logger.info(f"Active scan progress: {progress}%")
            time.sleep(5)
        
        self.logger.info("Active scan completed")
        return scan_id
    
    def passive_scan(self, target_url: str) -> None:
        """Enable passive scanning."""
        self.logger.info("Enabling passive scan")
        self.zap.pscan.enable_all_scanners()
        
        # Access the target URL to trigger passive scanning
        self.zap.core.access_url(target_url)
        
        # Wait for passive scan to complete
        while int(self.zap.pscan.records_to_scan) > 0:
            self.logger.info(f"Passive scan records remaining: {self.zap.pscan.records_to_scan}")
            time.sleep(2)
        
        self.logger.info("Passive scan completed")
    
    def get_alerts(self, risk_level: Optional[str] = None) -> List[Dict]:
        """Get security alerts from scan results."""
        alerts = self.zap.core.alerts()
        
        if risk_level:
            # Filter by risk level (High, Medium, Low, Informational)
            alerts = [alert for alert in alerts if alert['risk'] == risk_level]
        
        return alerts
    
    def generate_report(self, report_format: str = 'html') -> str:
        """Generate security scan report."""
        if report_format.lower() == 'html':
            return self.zap.core.htmlreport()
        elif report_format.lower() == 'xml':
            return self.zap.core.xmlreport()
        elif report_format.lower() == 'json':
            return json.dumps(self.zap.core.alerts(), indent=2)
        else:
            raise ValueError(f"Unsupported report format: {report_format}")
    
    def save_report(self, report_content: str, filename: str) -> None:
        """Save report to file."""
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(report_content)
        self.logger.info(f"Report saved to {filename}")
    
    def comprehensive_scan(self, target_url: str, config: Dict) -> Dict:
        """Perform comprehensive security scan."""
        results = {
            'target_url': target_url,
            'scan_start_time': time.time(),
            'spider_scan_id': None,
            'active_scan_id': None,
            'alerts': [],
            'summary': {}
        }
        
        try:
            # Configure scanner
            self.configure_scanner(config)
            
            # Perform spider scan
            if config.get('enable_spider', True):
                results['spider_scan_id'] = self.spider_scan(
                    target_url, 
                    config.get('spider_max_depth', 5)
                )
            
            # Perform passive scan
            if config.get('enable_passive', True):
                self.passive_scan(target_url)
            
            # Perform active scan
            if config.get('enable_active', True):
                results['active_scan_id'] = self.active_scan(
                    target_url,
                    config.get('scan_policy')
                )
            
            # Get alerts
            results['alerts'] = self.get_alerts()
            
            # Generate summary
            results['summary'] = self._generate_summary(results['alerts'])
            
            results['scan_end_time'] = time.time()
            results['scan_duration'] = results['scan_end_time'] - results['scan_start_time']
            
        except Exception as e:
            self.logger.error(f"Scan failed: {str(e)}")
            results['error'] = str(e)
        
        return results
    
    def _generate_summary(self, alerts: List[Dict]) -> Dict:
        """Generate summary statistics from alerts."""
        summary = {
            'total_alerts': len(alerts),
            'high_risk': 0,
            'medium_risk': 0,
            'low_risk': 0,
            'informational': 0,
            'unique_vulnerabilities': set()
        }
        
        for alert in alerts:
            risk = alert.get('risk', '').lower()
            if risk == 'high':
                summary['high_risk'] += 1
            elif risk == 'medium':
                summary['medium_risk'] += 1
            elif risk == 'low':
                summary['low_risk'] += 1
            elif risk == 'informational':
                summary['informational'] += 1
            
            # Track unique vulnerability types
            summary['unique_vulnerabilities'].add(alert.get('alert', 'Unknown'))
        
        summary['unique_vulnerabilities'] = list(summary['unique_vulnerabilities'])
        return summary


class ZAPScanConfiguration:
    """Configuration templates for different types of security scans."""
    
    @staticmethod
    def web_application_scan() -> Dict:
        """Configuration for web application security scan."""
        return {
            'enable_spider': True,
            'enable_passive': True,
            'enable_active': True,
            'spider_max_depth': 10,
            'scan_policy': 'Default Policy',
            'headers': {
                'User-Agent': 'ZAP Security Scanner'
            }
        }
    
    @staticmethod
    def api_security_scan() -> Dict:
        """Configuration for API security scan."""
        return {
            'enable_spider': False,  # APIs don't need spidering
            'enable_passive': True,
            'enable_active': True,
            'scan_policy': 'API-minimal',
            'headers': {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
        }
    
    @staticmethod
    def authenticated_scan(username: str, password: str, login_url: str) -> Dict:
        """Configuration for authenticated security scan."""
        return {
            'enable_spider': True,
            'enable_passive': True,
            'enable_active': True,
            'spider_max_depth': 8,
            'auth': {
                'type': 'form',
                'username': username,
                'password': password,
                'login_url': login_url,
                'login_data': f'username={username}&password={password}',
                'context_name': 'Authenticated Context'
            }
        }
    
    @staticmethod
    def quick_scan() -> Dict:
        """Configuration for quick security scan."""
        return {
            'enable_spider': True,
            'enable_passive': True,
            'enable_active': False,  # Skip active scan for speed
            'spider_max_depth': 3
        }


# Example usage and test functions
def test_zap_scanner():
    """Test ZAP scanner functionality."""
    scanner = ZAPSecurityScanner()
    
    # Test configuration
    config = ZAPScanConfiguration.web_application_scan()
    
    # Mock target URL (in real tests, use actual test environment)
    target_url = "http://localhost:8000"
    
    try:
        # Perform comprehensive scan
        results = scanner.comprehensive_scan(target_url, config)
        
        # Validate results
        assert 'target_url' in results
        assert 'alerts' in results
        assert 'summary' in results
        
        # Generate and save report
        html_report = scanner.generate_report('html')
        scanner.save_report(html_report, 'security_scan_report.html')
        
        return results
        
    except Exception as e:
        print(f"ZAP scanner test failed: {e}")
        return None


def test_scan_configurations():
    """Test different scan configurations."""
    configs = [
        ZAPScanConfiguration.web_application_scan(),
        ZAPScanConfiguration.api_security_scan(),
        ZAPScanConfiguration.quick_scan()
    ]
    
    for i, config in enumerate(configs):
        assert isinstance(config, dict)
        assert 'enable_spider' in config
        assert 'enable_passive' in config
        assert 'enable_active' in config
        print(f"Configuration {i+1} validated successfully")


if __name__ == "__main__":
    # Run tests
    test_scan_configurations()
    
    # Uncomment to run actual ZAP scan (requires ZAP to be running)
    # test_zap_scanner()

